import React, { useEffect, useRef, useState } from "react";
import Header from '../components/Header';
import Footer from '../components/Footer';

export default function ChatMockPage() {
  const [selectedIdx, setSelectedIdx] = useState(0);
  const [messages, setMessages] = useState([
    { id: "a1", role: "assistant", content: "안녕! 오늘은 어땠니?\n캐릭터 대답창" },
    { id: "u1", role: "user", content: "사용자 대답란" },
    { id: "a2", role: "assistant", content: "캐릭터 대답" },
    { id: "u2", role: "user", content: "좋았어요. 기분이 아주 좋은 하루였어요." },
    { id: "a3", role: "assistant", content: "정말 다행이네요. 어떤 일이 있었나요?" },
  ]);
  const [text, setText] = useState("");
  const [busy, setBusy] = useState(false);
  const endRef = useRef(null);

  useEffect(() => {
    endRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const send = async () => {
    const t = text.trim();
    if (!t || busy) return;
    setText("");
    setMessages((prev) => [...prev, { id: "u-" + Date.now(), role: "user", content: t }]);

    setBusy(true);
    try {
     const res = await fetch("http://localhost:8080/api/chat", {
       method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ message: t }),
     });
     const data = await res.json();

     setMessages((prev) => [
        ...prev,
       { id: "a-" + Date.now(), role: "assistant", content: data.reply },
     ]);
   } catch (err) {
      console.error(err);
     setMessages((prev) => [
        ...prev,
        { id: "a-" + Date.now(), role: "assistant", content: "⚠️ 서버 오류가 발생했습니다." },
      ]);
    } finally {
      setBusy(false);
    }
  };


  const onKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send();
    }
  };

  return (
  // 회색 배경 전체를 세로 플렉스로: 헤더 / 메인 / 푸터
  <div className="min-h-screen w-full bg-gray-200/70 flex flex-col font-sans">

    {/* 상단 회색 영역: Header */}

      <Header />

    {/* 가운데: 메인 보드(그대로) */}
    <div className="flex-1 flex items-center justify-center">
      <div className="w-[1200px] h-[680px] rounded-[48px] bg-gray-300/60 p-6 shadow-inner">
        <div className="w-full h-full rounded-[36px] bg-white overflow-hidden relative flex">
          {/* ===== 사이드바 ===== */}
          <aside className="w-[300px] bg-neutral-700 text-white relative overflow-hidden isolate">
            <div className="absolute inset-y-0 left-[-60px] w-[60px] bg-neutral-700 rounded-l-[48px]" />
            <div className="flex flex-col items-center pt-10 gap-6">
              {[0, 1, 2].map((idx) => (
                <AvatarItem
                  key={idx}
                  selected={selectedIdx === idx}
                  onClick={() => setSelectedIdx(idx)}
                />
              ))}
            </div>
          </aside>

          {/* ===== 채팅 본문 ===== */}
          <section className="flex-1 flex flex-col">
            <div className="flex-1 overflow-y-auto px-14 py-10 space-y-5">
              {messages.map((m) => (
                <Bubble key={m.id} role={m.role} content={m.content} />
              ))}
              <div ref={endRef} />
            </div>

            {/* ===== 입력창 ===== */}
            <div className="border-t px-14 py-6 bg-white">
              <div className="flex items-end gap-4">
                <textarea
                  className="flex-1 min-h-[56px] max-h-[140px] resize-none rounded-3xl border border-gray-300 px-6 py-4 text-lg
                             focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200"
                  placeholder="메시지 입력"
                  value={text}
                  onChange={(e) => setText(e.target.value)}
                  onKeyDown={onKeyDown}
                />
                <button
                  className="h-[56px] min-w-[100px] rounded-3xl bg-gray-200 hover:bg-gray-300 active:bg-gray-400
                             text-gray-900 text-xl font-medium shadow-sm transition-colors
                             disabled:bg-gray-100 disabled:text-gray-400"
                  onClick={send}
                  disabled={!text.trim() || busy}
                >
                  {busy ? (
                    <div
                      className="animate-spin h-5 w-5 border-2 border-current border-t-transparent rounded-full mx-auto"
                      role="status"
                      aria-label="loading"
                    />
                  ) : (
                    "전송"
                  )}
                </button>
              </div>
            </div>
          </section>
        </div>
      </div>
    </div>

    {/* 하단 회색 영역: Footer */}
      <Footer />

  </div>
);

}

const SIDEBAR_COLOR = "#404040";
const GRAY_FILL = "#d1d5db"; // Tailwind gray-300

/** ======================= 아바타 아이템 ======================= */
function AvatarItem({ selected = false, onClick }) {
  const SLOT_W = 300;
  const D = 80;
  const P = 18;
  const R = D / 2 + P;
  const H = D + 2 * P;
  const W_DEF = 200;
  const SLOT_H = H;
  const CY = SLOT_H / 2;
  const CX = 152;

  const CAPSULE_X = (CX - D / 2) - P;
  const CAPSULE_Y = CY - H / 2;
  const capsuleRight = CAPSULE_X + W_DEF;
  const W = capsuleRight > SLOT_W ? W_DEF - (capsuleRight - SLOT_W) : W_DEF;

  const cCenterX = CX - CAPSULE_X;
  const cCenterY = CY - CAPSULE_Y;
  const RING_T = 8;

  return (
    <div className="relative w-[300px]" style={{ height: `${SLOT_H}px`, cursor: "pointer" }} onClick={onClick}>
      {selected ? (
        <div
          className="absolute"
          style={{ left: CAPSULE_X, top: CAPSULE_Y, width: W, height: H, zIndex: 0 }}
        >
          <CapsuleWithNotch
            w={W}
            h={H}
            notchCx={cCenterX}
            notchCy={cCenterY}
            notchR={R}
            ringWidth={RING_T}
          />
        </div>
      ) : (
        <div
          className="absolute rounded-full bg-white border-[2px] border-gray-300"
          style={{
            left: CX - D / 2,
            top: CY - D / 2,
            width: D,
            height: D,
            zIndex: 1,
          }}
        />
      )}
    </div>
  );
}

/** ======================= 캡슐 SVG ======================= */
function CapsuleWithNotch({ w, h, notchCx, notchCy, notchR, ringWidth }) {
  const r = 70;
  const EXT = 10;
  const path = `M${w + EXT},0 H${r} a${r},${r} 0 0 0 -${r},${r} V${h - r} a${r},${r} 0 0 0 ${r},${r} H${w + EXT} Z`;
  const mid = `m-${Math.random().toString(36).slice(2)}`;
  const avatarR = Math.max(0, notchR - ringWidth);

  return (
    <svg
      width={w + EXT}
      height={h}
      viewBox={`0 0 ${w + EXT} ${h}`}
      style={{ display: "block" }}
    >
      <defs>
        <mask id={mid}>
          {/* 🔹 mask의 깎는 원을 살짝 줄여서 경계 오차 제거 */}
          <path d={path} fill="white" />
          <circle cx={notchCx} cy={notchCy} r={notchR * 0.99} fill="black" />
        </mask>
      </defs>

      {/* 캡슐 회색 바탕 */}
      <path d={path} fill={GRAY_FILL} mask={`url(#${mid})`} />

      {/* 🔸 경계 덮기용 회색 원 (mask 아래쪽 남은 부분 완전 차단) */}
      <circle
        cx={notchCx}
        cy={notchCy}
        r={notchR * 1.005}  // ← 살짝 키워서 회색이 더 겹치도록
        fill={GRAY_FILL}
      />

      {/* 링(연한 회색 테두리) */}
      <circle
        cx={notchCx}
        cy={notchCy}
        r={notchR - ringWidth / 2}
        stroke={GRAY_FILL}
        strokeWidth={ringWidth}
        fill="none"
      />

      {/* 흰색 프로필 원 */}
      <circle cx={notchCx} cy={notchCy} r={avatarR} fill="white" />
      <circle
        cx={notchCx}
        cy={notchCy}
        r={avatarR}
        fill="none"
        stroke="#e5e7eb"
        strokeWidth="2"
      />
    </svg>
  );
}




/** ======================= 채팅 말풍선 ======================= */
function Bubble({ role, content }) {
  const mine = role === "user";
  const bgColor = mine ? "bg-blue-500" : "bg-gray-100";
  const textColor = "text-gray-900";
  const tailColorClass = mine ? "border-l-blue-500" : "border-r-gray-100";

  return (
    <div className={`flex w-full ${mine ? "justify-end" : "justify-start"}`}>
      <div
        className={`relative max-w-[70%] whitespace-pre-wrap break-words rounded-[18px] px-4 py-2 shadow-sm ${textColor} ${bgColor}`}
      >
        {content}
        <div
          className={`absolute w-0 h-0 border-t-[6px] border-b-[6px] ${
            mine
              ? `right-[-7px] border-l-[8px] ${tailColorClass}`
              : `left-[-7px] border-r-[8px] ${tailColorClass}`
          } border-t-transparent border-b-transparent`}
          style={{ top: "16px" }}
        />
      </div>
    </div>
  );
}
